

렌더링 성능 개선
우리의 응용 프로그램은 유용해 보이지만 실제로는 구성 요소를 다시 렌더링하는 시기와 방법에 몇 가지 결함이 있습니다. 이러한 문제를 살펴보고 성능을 개선할 수 있는 몇 가지 방법에 대해 이야기해 봅시다.

렌더링 동작 조사
React DevTools Profiler를 사용하여 상태가 업데이트될 때 어떤 구성 요소가 다시 렌더링되는지에 대한 일부 그래프를 볼 수 있습니다. 단일 사용자의 <UserPage>를 클릭해 보십시오. 브라우저의 DevTools를 열고 React "Profiler" 탭에서 왼쪽 상단에 있는 원형 "Record" 버튼을 클릭합니다. 그런 다음 앱에서 "Refresh Notifications" 버튼을 클릭하고 React DevTools Profiler에서 기록을 중지합니다. 다음과 같은 차트가 표시됩니다.

탭에서 업데이트된 "읽지 않은 알림" 배지를 표시해야 했기 때문에 <Navbar>가 다시 렌더링된 것을 볼 수 있습니다. 그런데 <UserPage>가 다시 렌더링된 이유는 무엇입니까?

Redux DevTools에서 마지막으로 발송된 작업 몇 개를 검사하면 알림 상태만 업데이트된 것을 볼 수 있습니다. <UserPage>는 알림을 읽지 않으므로 다시 렌더링하면 안 됩니다. 구성 요소에 문제가 있는 것 같습니다.

<UserPage>를 주의 깊게 살펴보면 특정한 문제가 있습니다.

액션이 발송될 때마다 useSelector가 다시 실행되고 새 참조 값을 반환하면 구성 요소가 강제로 다시 렌더링된다는 것을 알고 있습니다.

useSelector 후크 내에서 filter()를 호출하여 이 사용자에게 속한 게시물 목록만 반환합니다. 불행히도 이것은 useSelector가 항상 새로운 배열 참조를 반환한다는 것을 의미하므로 게시물 데이터가 변경되지 않은 경우에도 모든 작업 후에 구성 요소가 다시 렌더링됩니다!.

선택기 기능 메모하기
실제로 필요한 것은 state.posts 또는 userId가 변경된 경우에만 새 필터링된 배열을 계산하는 방법입니다. 변경되지 않은 경우 마지막으로 동일한 필터링된 배열 참조를 반환하려고 합니다.

이 아이디어를 "메모이제이션"이라고 합니다. 이전 입력 세트와 계산된 결과를 저장하고 입력이 동일하면 다시 계산하는 대신 이전 결과를 반환하려고 합니다.

지금까지 우리는 저장소에서 데이터를 읽기 위해 코드를 복사하여 붙여넣을 필요가 없도록 선택기 함수를 직접 작성했습니다. 선택기 기능을 메모화할 수 있는 방법이 있다면 좋을 것입니다.

Reselect는 메모이제이션된 선택자 함수를 생성하기 위한 라이브러리이며 Redux와 함께 사용하도록 특별히 설계되었습니다. 입력이 변경될 때만 결과를 다시 계산하는 메모화된 선택자를 생성하는 createSelector 함수가 있습니다. Redux Toolkit은 createSelector 함수를 내보내므로 이미 사용할 수 있습니다.

Reselect를 사용하여 새로운 selectPostsByUser 선택기 함수를 만들고 여기에서 사용하겠습니다.

createSelector는 하나 이상의 "입력 선택기" 함수와 "출력 선택기" 함수를 인수로 사용합니다. selectPostsByUser(state, userId)를 호출하면 createSelector는 모든 인수를 각 입력 선택기에 전달합니다. 이러한 입력 선택기가 반환하는 것은 무엇이든 출력 선택기의 인수가 됩니다.

이 경우 출력 선택기의 두 인수로 모든 게시물의 배열과 사용자 ID가 필요하다는 것을 알고 있습니다. 기존의 selectAllPosts 선택기를 재사용하여 게시물 배열을 추출할 수 있습니다. 사용자 ID는 selectPostsByUser에 전달하는 두 번째 인수이므로 userId만 반환하는 작은 선택기를 작성할 수 있습니다.

그런 다음 출력 선택기는 게시물과 사용자 ID를 가져와 해당 사용자에 대해서만 필터링된 게시물 배열을 반환합니다.

selectPostsByUser를 여러 번 호출하면 게시물 또는 userId가 변경된 경우에만 출력 선택기가 다시 실행됩니다.

메모이제이션 선택기는 불필요한 재렌더링을 피하고 입력 데이터가 변경되지 않은 경우 잠재적으로 복잡하거나 비용이 많이 드는 계산을 피하는 데 도움이 되므로 React Redux 애플리케이션의 성능을 개선하는 데 유용한 도구입니다.

게시물 목록 조사
<PostsList>로 돌아가서 React 프로파일러 추적을 캡처하는 동안 게시물 중 하나에서 반응 버튼을 클릭하면 <PostsList> 및 업데이트된 <PostExcerpt> 인스턴스 렌더링뿐만 아니라 모든 <PostExcerpt> 구성 요소가 렌더링된 것을 볼 수 있습니다.

왜 그런 겁니까? 다른 게시물은 변경되지 않았는데 왜 다시 렌더링해야 할까요?

React의 기본 동작은 상위 구성 요소가 렌더링될 때 React가 그 내부의 모든 하위 구성 요소를 재귀적으로 렌더링한다는 것입니다!. 한 게시물 객체의 불변 업데이트는 새로운 게시물 배열도 생성했습니다. 우리의 <PostsList>는 posts 배열이 새로운 참조였기 때문에 다시 렌더링해야 했습니다. 그래서 렌더링된 후 React는 아래쪽으로 계속해서 모든 <PostExcerpt> 구성 요소도 다시 렌더링했습니다.

작은 예제 앱에서는 심각한 문제가 아니지만 더 큰 실제 앱에서는 매우 긴 목록이나 매우 큰 구성 요소 트리가 있을 수 있으며 모든 추가 구성 요소를 다시 렌더링하면 속도가 느려질 수 있습니다.

<PostsList>에서 이 동작을 최적화할 수 있는 몇 가지 방법이 있습니다.

첫째, <PostExcerpt> 구성 요소를 React.memo()로 감쌀 수 있습니다. 이렇게 하면 소품이 실제로 변경된 경우에만 내부 구성 요소가 다시 렌더링되도록 할 수 있습니다. 이것은 실제로 매우 잘 작동할 것입니다. 시도해보고 어떤 일이 발생하는지 확인하십시오.

또 다른 옵션은 <PostsList>를 다시 작성하여 전체 게시물 배열 대신 상점에서 게시물 ID 목록만 선택하도록 하고 <PostExcerpt>를 다시 작성하여 postId 소품을 수신하고 useSelector를 호출하여 필요한 게시물 개체를 읽도록 하는 것입니다. <PostsList>가 이전과 동일한 ID 목록을 가져오면 다시 렌더링할 필요가 없으므로 변경된 <PostExcerpt> 구성 요소 하나만 렌더링해야 합니다.

안타깝게도 모든 게시물을 날짜별로 정렬하고 올바른 순서로 렌더링해야 하기 때문에 까다로워집니다. 배열을 항상 정렬된 상태로 유지하도록 postsSlice를 업데이트할 수 있으므로 구성 요소에서 배열을 정렬할 필요가 없으며 메모화된 선택기를 사용하여 게시물 ID 목록만 추출할 수 있습니다. 또한 useSelector(selectPostIds, shallowEqual)와 같이 결과를 확인하기 위해 useSelector가 실행하는 비교 함수를 사용자 정의할 수 있으므로 ID 배열의 내용이 변경되지 않은 경우 다시 렌더링을 건너뛸 수 있습니다.

마지막 옵션은 리듀서가 모든 게시물에 대해 별도의 ID 배열을 유지하고 게시물이 추가되거나 제거될 때만 해당 배열을 수정하고 <PostsList> 및 <PostExcerpt>를 동일하게 다시 작성하도록 하는 방법을 찾는 것입니다. 이렇게 하면 <PostsList>는 해당 ID 배열이 변경될 때만 다시 렌더링하면 됩니다.

편리하게도 Redux Toolkit에는 이를 수행하는 데 도움이 되는 createEntityAdapter 기능이 있습니다.


데이터 정규화
많은 로직이 ID 필드로 항목을 조회하고 있음을 확인했습니다. 데이터를 배열에 저장했기 때문에 찾고 있는 ID를 가진 항목을 찾을 때까지 array.find()를 사용하여 배열의 모든 항목을 반복해야 합니다.

현실적으로 이것은 그리 오래 걸리지 않지만 내부에 수백 또는 수천 개의 항목이 있는 배열이 있는 경우 하나의 항목을 찾기 위해 전체 배열을 살펴보는 것은 낭비되는 노력이 됩니다. 우리에게 필요한 것은 다른 모든 항목을 확인할 필요 없이 해당 ID를 기반으로 단일 항목을 직접 조회하는 방법입니다. 이 프로세스를 "정규화"라고 합니다.

정규화된 상태 구조
"정규화된 상태"는 다음을 의미합니다.

우리는 우리 주에 각 특정 데이터의 사본을 하나만 가지고 있으므로 중복이 없습니다.
정규화된 데이터는 항목 ID가 키이고 항목 자체가 값인 조회 테이블에 보관됩니다.
특정 항목 유형에 대한 모든 ID의 배열이 있을 수도 있습니다.
JavaScript 개체는 다른 언어의 "지도" 또는 "사전"과 유사한 조회 테이블로 사용할 수 있습니다. 사용자 개체 그룹의 정규화된 상태는 다음과 같습니다.

createEntityAdapter로 정규화된 상태 관리
Redux Toolkit의 createEntityAdapter API는 항목 모음을 가져와 { ids: [], entities: {} } 형태로 배치하여 슬라이스에 데이터를 저장하는 표준화된 방법을 제공합니다. 이 사전 정의된 상태 모양과 함께 해당 데이터로 작업하는 방법을 알고 있는 감속기 함수 및 선택기 세트를 생성합니다.

여기에는 몇 가지 이점이 있습니다.

정규화를 직접 관리하기 위해 코드를 작성할 필요가 없습니다.
createEntityAdapter의 미리 빌드된 리듀서 함수는 "이 모든 항목 추가", "하나의 항목 업데이트" 또는 "여러 항목 제거"와 같은 일반적인 경우를 처리합니다.
createEntityAdapter는 항목의 내용에 따라 정렬된 순서로 ID 배열을 유지할 수 있으며 항목이 추가/제거되거나 정렬 순서가 변경되는 경우에만 해당 배열을 업데이트합니다.
createEntityAdapter는 두 항목을 비교하여 항목 ID 배열을 정렬된 순서로 유지하는 데 사용되는 sortComparer 함수를 포함할 수 있는 옵션 개체를 허용합니다(Array.sort()와 동일한 방식으로 작동).

엔터티 상태 개체에서 항목을 추가, 업데이트 및 제거하기 위해 생성된 감속기 함수 집합이 포함된 개체를 반환합니다. 이러한 리듀서 함수는 특정 작업 유형에 대한 케이스 리듀서로 사용하거나 createSlice의 다른 리듀서 내에서 "변형" 유틸리티 함수로 사용할 수 있습니다.

어댑터 개체에는 getSelectors 함수도 있습니다. Redux 루트 상태에서 이 특정 상태 조각을 반환하는 선택기를 전달할 수 있으며 selectAll 및 selectById와 같은 선택기를 생성합니다.

마지막으로 어댑터 개체에는 빈 {ids: [], entities: {}} 개체를 생성하는 getInitialState 함수가 있습니다. getInitialState에 더 많은 필드를 전달할 수 있으며 병합됩니다.

거기에 많은 일이 있습니다! 그것을 분해합시다.

먼저 createEntityAdapter를 가져오고 이를 호출하여 postsAdapter 개체를 만듭니다. 우리는 모든 게시물 ID의 배열을 최신 게시물로 먼저 정렬하기를 원한다는 것을 알고 있으므로 post.date 필드를 기반으로 최신 항목을 맨 앞으로 정렬하는 sortComparer 함수를 전달합니다.

getInitialState()는 빈 {ids: [], entities: {}} 정규화된 상태 개체를 반환합니다. 우리의 postsSlice는 상태를 로드하기 위한 상태 및 오류 필드도 유지해야 하므로 getInitialState()에 전달합니다.

이제 게시물이 state.entities에서 조회 테이블로 유지되므로 이전 게시물 배열을 반복하는 대신 reactionAdded 및 postUpdated 감속기를 변경하여 ID로 올바른 게시물을 직접 조회할 수 있습니다.

fetchPosts.fulfilled 작업을 수신하면 postsAdapter.upsertMany 함수를 사용하여 초안 상태와 action.payload의 게시물 배열을 전달하여 들어오는 모든 게시물을 상태에 추가할 수 있습니다. 우리 상태에 이미 존재하는 action.payload에 항목이 있는 경우 upsertMany 함수는 일치하는 ID를 기반으로 항목을 병합합니다.

addNewPost.fulfilled 액션을 수신하면 하나의 새로운 게시물 객체를 상태에 추가해야 한다는 것을 알게 됩니다. 어댑터 함수를 리듀서로 직접 사용할 수 있으므로 해당 작업을 처리하는 리듀서 함수로 postsAdapter.addOne을 전달합니다.

마지막으로 이전에 손으로 작성한 selectAllPosts 및 selectPostById 선택기 기능을 postsAdapter.getSelectors에서 생성한 기능으로 대체할 수 있습니다. 선택기는 루트 Redux 상태 개체로 호출되므로 Redux 상태에서 게시물 데이터를 찾을 위치를 알아야 하므로 state.posts를 반환하는 작은 선택기를 전달합니다. 생성된 선택기 함수는 항상 selectAll 및 selectById라고 부르므로 ES6 구조 분해 구문을 사용하여 내보낼 때 이름을 바꾸고 이전 선택기 이름과 일치시킬 수 있습니다. <PostsList> 구성 요소에서 정렬된 게시물 ID 목록을 읽고 싶기 때문에 selectPostIds도 같은 방식으로 내보낼 것입니다.